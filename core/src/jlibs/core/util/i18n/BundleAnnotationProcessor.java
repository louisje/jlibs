/*
 * JLibs: Common Utilities for Java
 * Copyright (C) 2009  Santhosh Kumar T
 * <p/>
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * <p/>
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 */

package jlibs.core.util.i18n;

import jlibs.core.annotation.processing.AnnotationError;
import jlibs.core.annotation.processing.AnnotationProcessor;
import jlibs.core.annotation.processing.Printer;
import jlibs.core.lang.StringUtil;
import jlibs.core.lang.model.ModelUtil;

import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import javax.lang.model.util.ElementFilter;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Map;
import java.util.Set;

import static jlibs.core.util.i18n.PropertiesUtil.writeComments;
import static jlibs.core.util.i18n.PropertiesUtil.writeProperty;

/**
 * @author Santhosh Kumar T
 */
@SuppressWarnings({"unchecked"})
@SupportedAnnotationTypes("jlibs.core.util.i18n.ResourceBundle")
@SupportedSourceVersion(SourceVersion.RELEASE_6)
public class BundleAnnotationProcessor extends AnnotationProcessor{
    public static final String SUFFIX = "Impl";

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv){
        for(TypeElement annotation: annotations){
            for(Element elem: roundEnv.getElementsAnnotatedWith(annotation)){
                TypeElement c = (TypeElement)elem;
                BufferedWriter writer = null;
                Printer printer = null;
                try{
                    if(c.getKind()!=ElementKind.INTERFACE)
                        throw new AnnotationError(elem, ResourceBundle.class.getName()+" annotation can be applied only for interface");
                    
                    printer = Printer.get(c, SUFFIX);
                    printer.printPackage();

                    printer.println("import java.util.ResourceBundle;");
                    printer.println("import java.text.MessageFormat;");
                    printer.emptyLine(true);

                    printer.printClassDoc();
                    printer.println("public class "+printer.generatedClazz +" implements "+c.getSimpleName()+"{");
                    printer.indent++;
                    String pakage = ModelUtil.getPackage(c);
                    printer.println("private final ResourceBundle BUNDLE = ResourceBundle.getBundle(\""+pakage.replace('.', '/')+"/bundle\");");

                    FileObject resource = processingEnv.getFiler().createResource(StandardLocation.SOURCE_OUTPUT, pakage, "bundle.properties");
                    writer = new BufferedWriter(resource.openWriter());

                    writeComments(writer, " DON'T EDIT THIS FILE. THIS IS GENERATED BY JLIBS");
                    writeComments(writer, " @author Santhosh Kumar T");
                    writer.newLine();

                    while(c!=null && !c.getQualifiedName().contentEquals(Object.class.getName())){
                        process(c, writer, printer);
                        c = ModelUtil.getSuper(c);
                    }

                    printer.indent--;
                    printer.println("}");
                }catch(AnnotationError error){
                    error.report();
                }catch(IOException ex){
                    throw new RuntimeException(ex);
                }finally{
                    if(printer!=null)
                        printer.close();
                    try{
                        if(writer!=null)
                            writer.close();
                    }catch(IOException ex){
                        throw new RuntimeException(ex);
                    }
                }
            }
        }
        return true;
    }

    private void process(TypeElement c, BufferedWriter writer, Printer printer) throws IOException{
        for(ExecutableElement method: ElementFilter.methodsIn(c.getEnclosedElements())){
            AnnotationMirror mirror = ModelUtil.getAnnotationMirror(method, Message.class);
            if(mirror==null)
                throw new AnnotationError(method, Message.class.getName()+" annotation is missing on this method");
            if(!String.class.getName().equals(ModelUtil.toString(method.getReturnType())))
                throw new AnnotationError(method, "method annotated with "+Message.class.getName()+" must return java.lang.String");

            String doc = processingEnv.getElementUtils().getDocComment(method);
            String methodDoc = ModelUtil.getMethodDoc(doc);
            writeComments(writer, " "+methodDoc);

            printer.println("@Override");
            printer.print("public String "+method.getSimpleName()+"(");
            int i = 1;
            StringBuilder params = new StringBuilder();
            Map<String, String> paramDocs = ModelUtil.getMethodParamDocs(doc);
            for(VariableElement param : method.getParameters()){
                String key = param.getSimpleName().toString();
                String value = paramDocs.get(key);
                if(!StringUtil.isEmpty(value))
                    writeComments(writer, " {"+i+"} "+key+" --> "+value);

                params.append(", ");
                if(i>1)
                    printer.print(", ");
                params.append(key);
                printer.print(ModelUtil.toString(param.asType())+" "+key);
                i++;
            }

            AnnotationMirror messageMirror = ModelUtil.getAnnotationMirror(method, Message.class);
            String key = ModelUtil.getAnnotationValue(method, messageMirror, "key");
            if(StringUtil.isEmpty(key))
                key = method.getSimpleName().toString();
            String value = ModelUtil.getAnnotationValue(method, messageMirror, "value");
            writeProperty(writer, key, value);
            writer.newLine();

            printer.println("){");
            printer.indent++;
            printer.println("return MessageFormat.format(BUNDLE.getString(\""+key+"\")"+params+");");
            printer.indent--;
            printer.println("}");
        }
    }
}
